<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>最小表示法</title>
    <link href="/2022/08/08/minimum-representation/"/>
    <url>/2022/08/08/minimum-representation/</url>
    
    <content type="html"><![CDATA[<h3 id="循环同构">循环同构</h3><p>对于字符串 <span class="math inline">\(S,\ S.length = n,\\ \forall \i, \ S[i..n] + S[0..i-1]\)</span> 与 <spanclass="math inline">\(S\)</span> 循环同构。</p><h3 id="最小表示">最小表示</h3><p>字符串 <span class="math inline">\(S\)</span>的循环同构中字典序最小的字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minimumRepresentation</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">j</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span> = s.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (len &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = s[(i + len) % n]<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = s[(j + len) % n]<br>    <span class="hljs-keyword">if</span> (a == b) &#123;<br>      ++len<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>        ++i<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        ++j<br>      &#125;<br>      len = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">if</span> (i == j) &#123;<br>        ++i<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(i, j)<br>&#125;<br></code></pre></td></tr></table></figure><p>算法时间复杂度最好情况 <spanclass="math inline">\(O(n)\)</span>，最坏 <spanclass="math inline">\(O(n^2)\)</span><br />对于形如 <span class="math inline">\(s = yyy...yyx,\ s.length =n\)</span> 的数据，复杂度为 <spanclass="math inline">\(O(n^2)\)</span>。</p><h3 id="优化">优化</h3><p>对于长为 <span class="math inline">\(n\)</span> 的字符串 <spanclass="math inline">\(S\)</span> 的两个循环同构 <spanclass="math inline">\(S_i,\ S_j\ (i &lt; j)\)</span>, 易知 <spanclass="math inline">\(S_i,\ S_j\)</span> 是 <spanclass="math inline">\(2S = S + S\)</span> 的子字符串。假设它们的前 <spanclass="math inline">\(l\ (l &lt; n)\)</span> 个字符相同，即 <spanclass="math inline">\(S[i..i+l-1] = S[j..j+l-1]\)</span></p><p>如果它们的下一个字符 <span class="math inline">\(S[i+l] \not= S[j +l]\)</span>，不妨设 <span class="math inline">\(S[i+l] &lt;S[j+l]\)</span> 时，那么对 <span class="math inline">\(\forall k \in [0,l]\)</span>，<span class="math inline">\(S_{i+k} &lt;S_{j+k}\)</span></p><p><strong>证明</strong><br /><span class="math inline">\(S_{i+k} = S[i..i+l-1] + S[i+l] +S[i+l+1...]\)</span><br /><span class="math inline">\(S_{j+k} = S[j..j+l-1] + S[j+l] +S[j+l+1...]\)</span><br /><span class="math inline">\(\because S[i..i+l-1] = S[j..j+l-1],\ S[i+l]&lt; S[j+l]\)</span><br /><span class="math inline">\(\therefore S_{i+k} &lt; S_{j+k}\)</span></p><p><span class="math inline">\(S[i+l] &gt; S[j+l]\)</span>的情况类似。<br />所以 <span class="math inline">\(j\)</span> 可以跳过下标 <spanclass="math inline">\([j, j+l]\)</span>，直接去比较 <spanclass="math inline">\(S[i] 和 S[j+l+1]\)</span></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minimumRepresentation</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">j</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span> = s.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (len &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = s[(i + len) % n]<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = s[(j + len) % n]<br>    <span class="hljs-keyword">if</span> (a == b) &#123;<br>      ++len<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>        i = i + len + <span class="hljs-number">1</span><br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        j = j + len + <span class="hljs-number">1</span><br>      &#125;<br>      len = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">if</span> (i == j) &#123;<br>        ++i<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(i, j)<br>&#125;<br></code></pre></td></tr></table></figure><p>此时时间复杂度稳定在 <span class="math inline">\(O(n)\)</span>。</p>]]></content>
    
    
    <categories>
      
      <category>Algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>899. 有序队列</title>
    <link href="/2022/08/04/899-Orderly-Queue/"/>
    <url>/2022/08/04/899-Orderly-Queue/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/orderly-queue/">传送门</a></p><h3 id="思路">思路</h3><p>当 <span class="math inline">\(k = 1\)</span>时，变成找字典序最小的循环子串问题。<br />当 <span class="math inline">\(k &gt; 1\)</span>时，经过任意步移动一定可以将字符串 <spanclass="math inline">\(S\)</span> 变成升序字符串。</p><p><strong>证明</strong><br />当 <span class="math inline">\(k = 2\)</span>时，类比插入排序，可以假装将 <span class="math inline">\(S[0]\)</span>拿出，不停地将 <span class="math inline">\(S[1]\)</span>移动到字符串末尾，就好像字符串在旋转。转到合适的位置时，将 <spanclass="math inline">\(s[0]\)</span>插入字符串。经过若干次操作后，就能对字符串完成排序。 <pre><code class=" mermaid">flowchart LR01 --&gt; n-1n-1 --&gt; n-2n-2 -..-&gt; 33 --&gt; 22 --&gt; 1</code></pre></p><h3 id="实现">实现</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">orderlyQueue</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span>, k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">string</span> = s<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-property">length</span>; ++i) &#123;<br>            s = s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>) + s[<span class="hljs-number">0</span>]<br>            res = res &lt; s ? res : s<br>        &#125;<br>        <span class="hljs-keyword">return</span> res<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(s).<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p><span class="math inline">\(k = 1\)</span> 时，时间复杂度为 <spanclass="math inline">\(O(n^2)\)</span>，<br /><span class="math inline">\(k &gt; 1\)</span> 时，时间复杂度为 <spanclass="math inline">\(O(n \log n)\)</span></p><h3 id="k-1-情况的优化"><span class="math inline">\(k = 1\)</span>情况的优化</h3><p><span class="math inline">\(k = 1\)</span> 其实就是求字符串的<ahref="https://term-inator.github.io/2022/08/08/minimum-representation/">最小表示</a>，可以将时间复杂度优化到<span class="math inline">\(O(n)\)</span>。 <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minimumRepresentation</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">let</span> <span class="hljs-attr">len</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">i</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">j</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">number</span> = s.<span class="hljs-property">length</span><br>  <span class="hljs-keyword">while</span> (len &lt; n &amp;&amp; i &lt; n &amp;&amp; j &lt; n) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>: <span class="hljs-built_in">string</span> = s[(i + len) % n]<br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>: <span class="hljs-built_in">string</span> = s[(j + len) % n]<br>    <span class="hljs-keyword">if</span> (a == b) &#123;<br>      ++len<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">if</span> (a &gt; b) &#123;<br>        i = i + len + <span class="hljs-number">1</span><br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        j = j + len + <span class="hljs-number">1</span><br>      &#125;<br>      len = <span class="hljs-number">0</span><br>      <span class="hljs-keyword">if</span> (i == j) &#123;<br>        ++i<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(i, j)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">orderlyQueue</span>(<span class="hljs-params">s: <span class="hljs-built_in">string</span>, k: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">string</span> &#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-property">length</span> === <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> s<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">const</span> index = <span class="hljs-title function_">minimumRepresentation</span>(s)<br>        <span class="hljs-keyword">return</span> s.<span class="hljs-title function_">substring</span>(index) + s.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, index)<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> [...s].<span class="hljs-title function_">sort</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>刷题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LeetCode</tag>
      
      <tag>Hard</tag>
      
      <tag>最小表示法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Style Transfer</title>
    <link href="/2022/08/01/style-transfer/"/>
    <url>/2022/08/01/style-transfer/</url>
    
    <content type="html"><![CDATA[<style>.center {  width: auto;  display: table;  margin: auto;}.img-table {  margin-bottom: 0 !important;}.img-table-caption {  font-size: 0.8rem ;  color: #fefefe;  opacity: 0.65;  line-height: 1;  margin: -0.75rem auto 2rem;  text-align: center;  cursor: text;}</style><h3 id="摘要">摘要</h3><p>近几年风格迁移出现了各种各样的实现方案。本文是数字图像课程的期末项目报告，同时也作为课程项目的数字图像处理系统的一个功能。本文的模型改进了课程提供的代码，从将vgg16 改成 vgg19，ResidualBlock 改成 ResNextBlock，mse loss 改成 gram三个角度改进模型，使其在小数据集上的效果超过原模型。同时使用的不同种类的风格图和内容图进行迁移，比较效果。另外，本文还进行了消融实验，探究了改进的这三个部分在风格迁移起了什么作用。</p><p><strong>关键字:</strong> 风格迁移，卷积神经网络</p><h3 id="介绍">介绍</h3><p>风格迁移是一个出现了很久的问题，它研究一个将一张图片的风格应用到另一张图片上的问题。从问题提出到现在，大量研究者提出了各种各样的模型和解决方法。比如，RethinkingStyle Transfer: From Pixels to ParameterizedBrushstrokes<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="D. Kotovenko, M. Wright, A. Heimbrecht, and B. Ommer, “Rethinking style transfer: From pixels to parameterized brushstrokes,” CVPR, 2021.">[1]</span></a></sup>中提出需要将笔触考虑在内，能更好地还原风格图像的风格。StyleGAN3<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="T. Karras, M. Aittala, S. Laine, E. Härkönen, J. Hellsten, J. Lehtinen, and T. Aila, “Alias-free generative adversarial networks,” in Proc. NeurIPS, 2021.">[2]</span></a></sup>则更加强大，可以实现表情、年龄、性别、肤色等等的风格迁移。DALL-E2<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="A. Ramesh, P. Dhariwal, A. Nichol, C. Chu, and M. Chen, “Hierarchical text-conditional image generation with clip latents,” arXiv preprint arXiv:2204.06125, 2022.">[3]</span></a></sup>更为惊艳，基于 CLIP实现了将文字转换成图片的功能。用文字对场景进行描述即可生成一张符合描述的图片，用文字描述一种风格来完成类似风格迁移的功能也非常令人惊喜。</p><p>本文是数字图像课程的期末项目报告，不涉及这些前沿的研究，主要对提供的论文和代码进行改进<sup id="fnref:4" class="footnote-ref"><a href="#fn:4" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="[StyleTransferTrilogy](https://github.com/CortexFoundation/StyleTransferTrilogy)">[4]</span></a></sup>。本文涉及到的训练均在笔记本cpu 上完成，因此后文提到的训练时间都特指在这个 cpu 上训练的时间。</p><h3 id="相关工作">相关工作</h3><p>在 A neural algorithm of artistic style<sup id="fnref:5" class="footnote-ref"><a href="#fn:5" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="L. A. Gatys, A. S. Ecker, and M. Bethge, “A neural algorithm of artistic style,” arXiv preprint arXiv:1508.06576, 2015.">[5]</span></a></sup>中，提出用图像识别的思路提取内容图和风格图的特征，使用 Gram 矩阵求风格的 loss。Gram 矩阵是对 feature map做内积，就好像是高维空间的两个向量，向量之间的夹角 <spanclass="math inline">\(\theta\)</span> 越小，这两个向量就越相似，感觉类似Word Embedding。总的 loss 是内容的 loss 和风格的 loss 的和，当这个 loss变小，说明生成的图片和内容图、风格图都有相似之处，达成风格迁移的目标。但由于这个做法没有训练出模型，所以当内容图或风格图发生改变时，都要重新进行训练，生成一张图片要近30分钟，速度过于缓慢。将这样的算法嵌入期末项目的系统中显然是不合适的。</p><p>Perceptual losses for real-time style transfer and super-resolution<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="J. Johnson, A. Alahi, and L. Fei-Fei, “Perceptual losses for real-time style transfer and super resolution,” in European conference on computer vision. Springer, 2016, pp. 694–711.">[6]</span></a></sup>提出了一种固定风格任意内容的风格迁移方法。通过在 COCO2014 上训练TransformNet，得到某个风格图对应的模型。将这个模型应用在任意的内容图上都可以得到对应的迁移图像。然而，如果想要换一个风格，就要重新训练一个模型。如果想要实现用户上传两张图片，进行风格迁移的操作的话，这样的算法是不能满足需求的。对于用户上传的风格图，系统不知道该用哪一个模型进行风格迁移。因此，这个方法也是不合适的。</p><p>Meta networks for neural style transfer<sup id="fnref:7" class="footnote-ref"><a href="#fn:7" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="F. Shen, S. Yan, and G. Zeng, “Meta networks for neural style transfer,” arXiv preprint arXiv:1709.04111, 2017.">[7]</span></a></sup>提出了任意风格任意内容的风格迁移方法。通过在 COCO2014 和 WikiArt上训练一个 MetaNet，然后将训练出来的权值赋给TransformNet，完成风格迁移。在训练的过程中，每次迭代都将 MetaNet训练得到的权值赋值给 TransformNet，然后用 TransformNet对图像进行操作，得到转换后的图像。用这个图像和内容图、风格图比较，求出内容loss 和风格loss。这个方法是满足系统的需求的，因此本文对这个模型进行改进。本文中，这篇文章中提出的模型称作原模型，本文的模型称作改进模型。改进的方向是在数据集比较小的情况下，如何让这个模型的表现超过原来的模型。</p><h3 id="改进方法">改进方法</h3><p>由于论文使用数据集非常大，COCO2014 有 82783 张内容图，WikiArt 中也有79433 张风格图。另外，目前设备的 GPU 显存只有2G，运行论文的代码会爆显存，所以只能在 cpu上训练。但是直接运行代码发现一个 epoch 就要 80 小时左右， 22个 epoch也就是 73 天，这显然是不能接受的。所以本文从内容、风格数据集中分别提取出500 张和 1000 张图片进行训练，缩短训练时间。每次取图片的 seed 均为42。本文“大小为 500 的数据集”指内容图 500 张和风格图 500 张。“大小为1000 的数据集”指内容图 1000 张和风格图 1000 张。</p><h4 id="替换-backbone">替换 backbone</h4><p>原来的网络中使用的是 vgg16 来提取图像特征，所以想到改用 vgg19。原先模型使用的是 vgg16 的 3, 8, 5, 22 层，根据图 <ahref="#fig:vgg">vgg</a>，这些层都是 maxpooling 的前一层。所以换成 vgg19后，应该相应地使用 3, 8, 17, 26 层。 <img src="/img/2022/08/01/vgg.png"id="fig:vgg" alt="vgg[8]" /></p><h4 id="替换-residual-block">替换 residual block</h4><p>根据图 <a href="#fig:transform_net">transform net</a>，原来的TransformNet 在上采样和下采样之间有 5 个 ResidualBlock，所以想到 ResNet的升级版ResNeXt<sup id="fnref:9" class="footnote-ref"><a href="#fn:9" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="S. Xie, R. Girshick, P. Dollár, Z. Tu, and K. He, “Aggregated residual transformations for deep neural networks,” in Proceedings of the IEEE conference on computer vision and pattern recognition, 2017, pp. 1492–1500.">[9]</span></a></sup>，用一个ResNeXtBlock 代替原来的ResidualBlock。ResNeXtBlock的入通道和出通道保持相同，内部有 32 个相同的分支。没有采用 5 个ResNeXtBlock 的原因是这样的结构非常消耗计算资源，一个 ResNextBlock带来的时间开销已经大幅超过了 5 个 ResidualBlock。原先的模型训练 1 个epoch 只需要约 25 分钟，修改后的模型则需要约 35 分钟。</p><p>这也是合理的，相当于用 32 个分支代替了 5个串行的结构，训练量增加了。但本文没有将 ResNextBlock 所有的参数都传入TransformNet 中，中间 32 个分支的参数没有存入 TransformNet，因为这些分支参数量相当大，没有必要放入TransformNet，而且放入的话内存不够，所以舍弃。 <imgsrc="/img/2022/08/01/transform_net.png" id="fig:transform_net"alt="transform net[7]" /></p><h4 id="替换-style-loss">替换 style loss</h4><p>Gram 矩阵适合用来比较图像的相似度，所以这里用 Gram矩阵代替原来训练用的 MSE loss。由于修改了 loss 计算方法，所以 style loss的 weight 也需要做调整。为了让 style loss 和 content loss的值相近，weight 选择 3e5。</p><h3 id="实验结果">实验结果</h3><strong>训练时间显著增长。</strong> 表<ahref="#tab:training_time">训练时间</a>展示的是两个模型大致的训练时间。<a name="tab:training_time"></a><div class="center"><center>训练时间</center><table><th><td>原模型</td><td>改进模型</td></th><tr><td>500</td><td>22min</td><td>50min</td></tr><tr><td>1000</td><td>35min</td><td>80min</td></tr></table></div><p>可以看出数据集翻倍后，训练花费的时间近似于翻倍。改进模型花费的时间约为原模型的1.6倍。相应的，用模型进行风格迁移的时间也变长了。由于原模型风格迁移的过程是先指定风格图片，训练20 个 batch，得到一个类似 Perceptual losses for real-time style transferand super-resolution<sup id="fnref:6" class="footnote-ref"><a href="#fn:6" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="J. Johnson, A. Alahi, and L. Fei-Fei, “Perceptual losses for real-time style transfer and super resolution,” in European conference on computer vision. Springer, 2016, pp. 694–711.">[6]</span></a></sup>中的固定风格任意内容的风格迁移模型，然后将该模型应用到大量图片上，所以风格迁移的时间是20 个 batch 的训练时间（较长）+转换时间（与图片数量有关）。因此这里比较的是转换一张图的时间，近似认为是20 个 batch 的训练时间。原模型大约是 8-10 分钟，改进模型大约是 12-14分钟。</p><p><strong>模型文件缩小。</strong> 由于改进模型只保存了 ResNeXtBlock的两层，相比于原模型的五层ResidualBlock，模型文件大幅缩小。原模型的两个模型文件约为850MB，改进模型的两个模型文件约为 647 MB，约为原模型的 <spanclass="math inline">\(\frac{3}{4}\)</span>。</p><p><strong>小数据集。</strong> 相比于原模型的 80K的训练，改进模型的训练集仅为 <spanclass="math inline">\(\frac{1}{160}\)</span> 和 <spanclass="math inline">\(\frac{1}{80}\)</span>，大幅减少了训练时间，并且二者在大小为500 和 1000的数据集上训练后，进行风格迁移的效果差不多，甚至改进模型更好，见<ahref="#app:comparison">附录</a>。</p><p>选择的<a href="#fig:style">风格图</a>色调上包含红、黄、绿、蓝、黑、白等常见的颜色，内容上包含人像、自然景物、建筑等，绘画流派上包含了抽象派、印象派等。依次为18993，29052，30925，78717，mosaic，带珍珠耳环的少女，picasso，星月夜。前四个是COCO2014 中的编号。后文以这些名称指代这些风格图。 选择的<ahref="#fig:content">内容图</a>主要为人像、动物、建筑、景物和文字，其中两张是黑白图。 另外，在这 8张风格图和 8 张内容图中，各有一半不在训练集中。</p><a name="fig:style"></a><table class="img-table"><tr><td><img src="/img/2022/08/01/18993.png"/></td><td><img src="/img/2022/08/01/29052.png"/></td><td><img src="/img/2022/08/01/30925.png"/></td><td><img src="/img/2022/08/01/78717.png"/></td></tr></table><center><a class="img-table-caption">数据集内的风格图</a></center><table class="img-table"><tr><td><img src="/img/2022/08/01/mosaic.png"/></td><td><img src="/img/2022/08/01/pearl.png"/></td><td><img src="/img/2022/08/01/picasso.png"/></td><td><img src="/img/2022/08/01/star.png"/></td></tr></table><center><a class="img-table-caption">数据集外的风格图</a></center><center><a class="img-table-caption">风格图</a></center><br /><a name="fig:content"></a><table class="img-table"><tr><td><img src="/img/2022/08/01/content_0.png"/></td></tr></table><center><a class="img-table-caption">数据集内的内容图</a></center><table class="img-table"><tr><td><img src="/img/2022/08/01/content_1.png"/></td></tr></table><center><a class="img-table-caption">数据集外的内容图</a></center><center><a class="img-table-caption">内容图</a></center><p><br />从附录的图中可以看出，原模型的迁移结果有许多斑点，仿佛绘画的时候颜料撒了，在画布上晕染开来，而且色块颜色和其他地方非常不协调。而改进模型没有这个问题。 尤其是在大小 500的数据集上训练的改进模型，整体颜色都比较协调。 在大小 1000的数据集上训练的改进模型虽然也有一些突出的色块，但色块的颜色不突兀，出现的位置相比原模型也更合理，都是一些原图明亮的、偏白色的位置。 但目前并不清楚为什么数据集变大了会出现这样的现象。</p><p><strong>权值不停增大的问题依然存在。</strong> 由于没有在 80K的数据集上训练，所以无法得出解决权值不停增大的结论。 图 <ahref="#fig:weight">权值</a> 显示 transform_net.downsampling.1.weight 的权值。可以看出改进模型权值上升的趋势明显，至少在大小 500 和 1000上权值在不停增大，而不是稳定在一个区间内。另外，改进模型权值的上升速度比原模型快，相同的迭代次数下，改进模型的权值普遍比原模型高，这可能也是改进模型效果更好的原因。</p><a name="fig:weight"></a><table class="img-table"><tr><td><img src="/img/2022/08/01/weight_000_500.png"/></td><td><img src="/img/2022/08/01/weight_000_1000.png"/></td></tr><tr><td><img src="/img/2022/08/01/weight_111_500.png"/></td><td><img src="/img/2022/08/01/weight_111_1000.png"/></td></tr><tr></table><center><a class="img-table-caption">模型权值</a></center><p><br />由于改进模型修改了原模型的三个地方，所以本文做了消融实验探究各个地方的改进分别对风格迁移起了什么作用，见<a href="#app:ablation">附录</a>。这部分的实验都是在大小为 500 的数据集上进行。</p><p>从图中可以看出，vgg16+resnext+gram 处理白色的效果不好。虽然在大小为1000的数据集上训练的改进模型在原图明亮的位置也用了和周围不同的颜色，但饱和度低，和周围的颜色是相近、协调的。而vgg16+resnext+gram的版本用了饱和度很高、鲜艳的颜色代替原图中明亮的位置，非常突兀。vgg19+resnet+gram处理黑色的效果不好。在原图黑色或偏暗的位置出现了饱和度很高的颜色，如红色、绿色、白色，并且这些颜色出现的位置不连续。vgg19+resnext+mse处理阴影的效果不好。在人物影子、水面倒影、云层阴影的位置都用了和周围相差很大、不协调、饱和度很低的颜色。</p><p>所以推测 vgg19 能更好地理解图像，能更正确地按语义分割图像，从而在合适的位置替换合适的颜色。resnext 和 gram 则是优化了黑色和阴影的转换，是图像的颜色更协调、线条更平滑。</p><h3 id="总结">总结</h3><p>本文通过分析三种风格迁移的方案，根据方案的可拓展性和运行时间确定可以在数字图像处理系统中应用的方案，并对该方案的模型进行改进。本文从将vgg16 改成 vgg19，ResidualBlock 改成 ResNextBlock，mse loss 改成 gram三个角度改进模型，使其在小数据集上的效果超过原模型。同时使用的不同种类的风格图和内容图进行迁移，比较效果。可以看出改进模型的风格迁移效果要优于原模型，但代价是更多的训练时间和迁移时间。</p><p>本文还进行了消融实验，探究了改进的这三个部分在风格迁移中起了什么作用，得出修改的每一部分对模型的效果都起到了作用。遗憾的一点是受制于设备，无法让其在80K的数据集上进行训练，所以也无法得知在大数据集上，改进模型的效果是否优于原模型。而且，即使在《18993》，《29052》，《78717》，《星月夜》等风格图上取得了不错的效果，但在转换一些特定的图片上，模型的效果并不好。比如《30925》或《戴珍珠耳环的少女》。这两张图都有占比较少的、使画面丰富的颜色，如亮绿色和淡蓝色。可以看出原模型尝试在图像中引入这些颜色，虽然这些颜色出现的位置非常奇怪。但改进模型迁移的结果中完全没有这些颜色，取而代之的是占据大部分画面的黄色和黑色。虽然改进模型的结果更自然，但很难让人从迁移结果中联想出风格图的内容。</p><p>另外，原模型和改进模型都有图像不清晰的问题。因此模型还有许多地方有待改进，但受制于时间等因素，本文没能继续进行改进。</p><h3 id="a-效果对比">A 效果对比</h3><p><a name="app:comparison"></a></p><details><summary>18993</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/18993_000_500_0.png"/></td><td><img src="/img/2022/08/01/18993.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/18993_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/18993_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/18993_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/18993_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/18993_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/18993_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/18993_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>29052</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/29052_000_500_0.png"/></td><td><img src="/img/2022/08/01/29052.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/29052_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/29052_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/29052_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/29052_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/29052_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/29052_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/29052_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>30925</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/30925_000_500_0.png"/></td><td><img src="/img/2022/08/01/30925.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/30925_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/30925_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/30925_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/30925_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/30925_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/30925_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/30925_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>78717</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/78717_000_500_0.png"/></td><td><img src="/img/2022/08/01/78717.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/78717_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/78717_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/78717_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/78717_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/78717_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/78717_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/78717_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>mosaic</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/mosaic_000_500_0.png"/></td><td><img src="/img/2022/08/01/mosaic.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/mosaic_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/mosaic_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/mosaic_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/mosaic_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/mosaic_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/mosaic_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/mosaic_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>pearl</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/pearl_000_500_0.png"/></td><td><img src="/img/2022/08/01/pearl.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/pearl_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/pearl_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/pearl_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/pearl_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/pearl_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/pearl_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/pearl_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>picasso</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/picasso_000_500_0.png"/></td><td><img src="/img/2022/08/01/picasso.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/picasso_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/picasso_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/picasso_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/picasso_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/picasso_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/picasso_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/picasso_111_1000_1.png"/></td><td></td></tr></table></details><details><summary>star</summary><table><tr><td>原模型 500</td><td><img src="/img/2022/08/01/comparison/star_000_500_0.png"/></td><td><img src="/img/2022/08/01/star.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/star_000_500_1.png"/></td><td></td></tr><tr><td>原模型 1000</td><td><img src="/img/2022/08/01/comparison/star_000_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/star_000_1000_1.png"/></td><td></td></tr><tr><td>改进模型 500</td><td><img src="/img/2022/08/01/comparison/star_111_500_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/star_111_500_1.png"/></td><td></td></tr><tr><td>改进模型 1000</td><td><img src="/img/2022/08/01/comparison/star_111_1000_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/comparison/star_111_1000_1.png"/></td><td></td></tr></table></details><h3 id="b-消融实验结果">B 消融实验结果</h3><p><a name="app:ablation"></a></p><details><summary>18993</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_18993_111_0.png"/></td><td><img src="/img/2022/08/01/18993.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_18993_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_18993_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_18993_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_18993_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_18993_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_18993_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_18993_110_1.png"/></td><td></td></tr></table></details><details><summary>29052</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_29052_111_0.png"/></td><td><img src="/img/2022/08/01/29052.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_29052_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_29052_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_29052_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_29052_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_29052_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_29052_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_29052_110_1.png"/></td><td></td></tr></table></details><details><summary>30925</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_30925_111_0.png"/></td><td><img src="/img/2022/08/01/30925.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_30925_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_30925_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_30925_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_30925_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_30925_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_30925_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_30925_110_1.png"/></td><td></td></tr></table></details><details><summary>78717</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_78717_111_0.png"/></td><td><img src="/img/2022/08/01/78717.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_78717_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_78717_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_78717_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_78717_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_78717_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_78717_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_78717_110_1.png"/></td><td></td></tr></table></details><details><summary>mosaic</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_mosaic_111_0.png"/></td><td><img src="/img/2022/08/01/mosaic.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_mosaic_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_mosaic_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_mosaic_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_mosaic_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_mosaic_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_mosaic_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_mosaic_110_1.png"/></td><td></td></tr></table></details><details><summary>pearl</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_pearl_111_0.png"/></td><td><img src="/img/2022/08/01/pearl.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_pearl_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_pearl_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_pearl_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_pearl_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_pearl_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_pearl_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_pearl_110_1.png"/></td><td></td></tr></table></details><details><summary>picasso</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_picasso_111_0.png"/></td><td><img src="/img/2022/08/01/picasso.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_picasso_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_picasso_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_picasso_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_picasso_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_picasso_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_picasso_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_picasso_110_1.png"/></td><td></td></tr></table></details><details><summary>star</summary><table><tr><td>改进模型 vgg19 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_star_111_0.png"/></td><td><img src="/img/2022/08/01/star.png"/></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_star_111_1.png"/></td><td></td></tr><tr><td>vgg16 resnext gram</td><td><img src="/img/2022/08/01/ablation/abl_star_011_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_star_011_1.png"/></td><td></td></tr><tr><td>vgg19 resnet gram</td><td><img src="/img/2022/08/01/ablation/abl_star_101_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_star_101_1.png"/></td><td></td></tr><tr><td>vgg19 resnext mse</td><td><img src="/img/2022/08/01/ablation/abl_star_110_0.png"/></td><td></td></tr><tr><td></td><td><img src="/img/2022/08/01/ablation/abl_star_110_1.png"/></td><td></td></tr></table></details><h3 id="参考文献">参考文献</h3><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>D. Kotovenko, M. Wright, A.Heimbrecht, and B. Ommer, “Rethinking style transfer: From pixels toparameterized brushstrokes,” CVPR, 2021.<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>T. Karras, M. Aittala, S.Laine, E. Härkönen, J. Hellsten, J. Lehtinen, and T. Aila, “Alias-freegenerative adversarial networks,” in Proc. NeurIPS, 2021.<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>A. Ramesh, P. Dhariwal, A.Nichol, C. Chu, and M. Chen, “Hierarchical text-conditional imagegeneration with clip latents,” arXiv preprint arXiv:2204.06125, 2022.<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:4" class="footnote-text"><span><ahref="https://github.com/CortexFoundation/StyleTransferTrilogy">StyleTransferTrilogy</a><a href="#fnref:4" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:5" class="footnote-text"><span>L. A. Gatys, A. S. Ecker,and M. Bethge, “A neural algorithm of artistic style,” arXiv preprintarXiv:1508.06576, 2015.<a href="#fnref:5" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:6" class="footnote-text"><span>J. Johnson, A. Alahi, and L.Fei-Fei, “Perceptual losses for real-time style transfer and superresolution,” in European conference on computer vision. Springer, 2016,pp. 694–711. <a href="#fnref:6" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:7" class="footnote-text"><span>F. Shen, S. Yan, and G.Zeng, “Meta networks for neural style transfer,” arXiv preprintarXiv:1709.04111, 2017.<a href="#fnref:7" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:8" class="footnote-text"><span>K. Simonyan and A.Zisserman, “Very deep convolutional networks for large-scale imagerecognition,” arXiv preprint arXiv:1409.1556, 2014.<a href="#fnref:8" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:9" class="footnote-text"><span>S. Xie, R. Girshick, P.Dollár, Z. Tu, and K. He, “Aggregated residual transformations for deepneural networks,” in Proceedings of the IEEE conference on computervision and pattern recognition, 2017, pp. 1492–1500.<a href="#fnref:9" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Deep Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Convolutional Neural Networks</tag>
      
      <tag>Style Transfer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>100 Prisoners Problem</title>
    <link href="/2022/07/29/100-prisoners-problem/"/>
    <url>/2022/07/29/100-prisoners-problem/</url>
    
    <content type="html"><![CDATA[<h3 id="问题描述">问题描述</h3><p><strong>背景</strong>：假设有 100 名从 1 - 100编号的囚犯，100张写有他们编号的纸条。这些纸条被放在密闭房间的 100个盒子中，编号也是 1 - 100。<br /><strong>操作</strong>：每名囚犯可以依次单独进入房间，打开这 100个盒子中的任意 50 个。<br /><strong>限制</strong>：完成后，他们必须还原并离开房间，并且无法以任何方式和其他囚犯交流。</p><p>在操作开始前，囚犯们可以商讨对策。<br /><strong>成功条件</strong>：所有囚犯在盒子中找到自己的编号。</p><h3 id="策略">策略</h3><h4 id="随机查看盒子">随机查看盒子</h4><p>每个囚犯找到自己编号的概率为 <spanclass="math inline">\(\frac{1}{2}\)</span><br />成功概率 P(success) = <span class="math inline">\((\frac{1}{2})^{100}\approx 0.000 0000000000000000000000000008\)</span></p><h4 id="循环链表策略">循环链表策略</h4><p>囚犯 <span class="math inline">\(P_a\)</span>进入房间后，先去找自己编号对应的盒子 <spanclass="math inline">\(B_a\)</span>，如果 <spanclass="math inline">\(B_a\)</span> 中的纸条是 a，则直接完成。<br />如果 <span class="math inline">\(B_a\)</span> 中的纸条为 b (<spanclass="math inline">\(b \not= a\)</span>)，则 <spanclass="math inline">\(P_a\)</span> 再去找盒子 <spanclass="math inline">\(B_b\)</span> ...... 直到找到盒子 <spanclass="math inline">\(B_n(1 \leq n \leq 100)\)</span>，其中的纸条为 a。<pre><code class=" mermaid">flowchart TB    A(开始) --&gt; Box_a    subgraph Box_a    b    end    subgraph Box_b    x    end    subgraph Box_n    a    end    b --&gt; Box_b    x -.若干步.-&gt; Box_n    a --&gt; Box_a</code></pre> 根据策略定义函数 <span class="math inline">\(f: B \toB\)</span>，含义：根据当前打开盒子中的纸条编号找到下一个盒子 <spanclass="math display">\[\begin{aligned}&amp; f(B_x)=B_{(x+k)\mod 100}, \\&amp; 0 &lt; x \leq 100, x \in \mathbb{Z}\\&amp; 0 \leq k &lt; 100, k \in \mathbb{Z}\end{aligned}\]</span></p><p><br /><strong>定理 1</strong> <span class="math display">\[\begin{aligned}&amp; \forall i \in \{x | 0 &lt; x \leq 100, x \in \mathbb{Z} \},\\&amp; \exists n \in \{x | 0 \leq x &lt; 100, x \in \mathbb{Z} \},\\&amp; f^n(B_i) = B_i\end{aligned}\]</span> <strong>证明</strong><br />即证 <span class="math inline">\(\exists n,\ (i + \sum_{j=1}^{n}k_j)\mod 100 = i\)</span><br />即证 <span class="math inline">\(\exists k&#39;,\ (i + k&#39;) \mod 100= i,\, 0 \leq k&#39; &lt; 100\)</span> 显然存在这样的 <spanclass="math inline">\(k&#39;\)</span>。</p><p>所以集合 B 由一系列不通长度的环形链表构成。这些链表构成集合 B的一个划分。</p><p><br /><strong>引理 1.</strong> <span class="math inline">\(f\)</span>可逆<br /><strong>证明</strong><br /><span class="math inline">\(\because\)</span> 盒子中的纸条是唯一的<br /><span class="math inline">\(\therefore\)</span>任意两个不同的盒子，内部的纸条不相同<br /><span class="math inline">\(\quad\)</span>即 <spanclass="math inline">\(\not\exists i,\ j,\ i \not= j, f(B_i) =f(B_j)\)</span><br /><span class="math inline">\(\therefore f\)</span> 是单射。<br /><span class="math inline">\(\therefore f\)</span> 可逆，且由于 <spanclass="math inline">\(f\)</span> 的定义域和值域相同， <spanclass="math inline">\(f^{-1}\)</span> 和 <spanclass="math inline">\(f\)</span> 的定义域相同。</p><p><br /><strong>定理 2</strong><br />根据引理 1 和引理 2，当 <span class="math inline">\(n \not= 1\)</span>时，<span class="math inline">\(f^{-1}(B_i) = f^{n -1}B_i\)</span>。<br />即囚犯可以通过执行 n - 1 次 <span class="math inline">\(f\)</span>操作找到对应的纸条。</p><p>所以只要保证不存在长度 &gt; 50的环形链表，囚犯就能按此策略找到自己的编号。<br />定义 <span class="math inline">\(Loop_n\)</span> 表示长度为 <spanclass="math inline">\(n\)</span> 的循环链表， <spanclass="math display">\[P(Loop_n) = \frac{环排列}{全排列} = \frac{\frac{P_n^n}{n}}{P_n^n} =\frac{1}{n}\]</span> <span class="math inline">\(P(Loop_{n&gt;50}) =\sum_{n=51}^{100}\frac{1}{n} \approx 0.6882\)</span><br /><span class="math inline">\(P(success) = 1 - P(Loop_{n&gt;50}) \approx0.3118\)</span></p><h3 id="有-2n-名囚犯时">有 <span class="math inline">\(2n\)</span>名囚犯时</h3><p>定义 <span class="math inline">\(H_n = \sum_{i=1}^n\frac{1}{n}\)</span><br /><span class="math inline">\(\begin{aligned} P(success) &amp; = 1 -(H_{2n} - H_n)\\ &amp; = 1 - (H_{2n} - \ln 2n) + (H_n - \ln2n)\\ &amp; =1 - (H_{2n} - \ln 2n) + (H_n - \ln n) - \ln 2 \end{aligned}\)</span></p><p>使用 Euler–Mascheroni 常数，<br /><span class="math inline">\(\lim \limits_{n \to \inf} (H_n - \ln n) =\gamma\)</span><br /><span class="math inline">\(\begin{aligned} \lim \limits_{n \to \inf}P(success) &amp; = 1 - \gamma + \gamma - \ln 2\\ &amp; = 1 - \ln 2\\&amp; = 0.3069 \end{aligned}\)</span></p><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://www.youtube.com/watch?v=iSNsgj1OCLA">TheRiddle That Seems Impossible Even If You Know The Answer</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span><a href="https://en.wikipedia.org/wiki/100_prisoners_problem">100Prisoners Problem</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Math</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Interesting Math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 创建 root 用户</title>
    <link href="/2022/07/22/linux-root-user/"/>
    <url>/2022/07/22/linux-root-user/</url>
    
    <content type="html"><![CDATA[<p>网上搜到的几乎一模一样，都有修改 /etc/sudoers文件的步骤，但是我这里并没有这个文件。所以在这里记录一份，省的以后忘了再去搜了。</p><h3 id="步骤">步骤</h3><ol type="1"><li>首先登录 root 账户</li><li>新建用户 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser <span class="hljs-variable">$&#123;username&#125;</span><br></code></pre></td></tr></table></figure></li><li>创建密码 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd <span class="hljs-variable">$&#123;username&#125;</span><br></code></pre></td></tr></table></figure></li><li>将用户加入 sudo 组 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">usermod -aG sudo <span class="hljs-variable">$&#123;username&#125;</span><br></code></pre></td></tr></table></figure></li><li>切换到该用户 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">su <span class="hljs-variable">$&#123;username&#125;</span><br></code></pre></td></tr></table></figure></li><li>使用 sudo<br />没有 sudo 命令的话，需要安装 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo <span class="hljs-built_in">ls</span> -la /root<br></code></pre></td></tr></table></figure></li></ol><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span><a href="https://phoenixnap.com/kb/create-a-sudo-user-on-debian">Howto Create a Sudo User on Debian</a><a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><ahref="https://linuxize.com/post/how-to-create-a-sudo-user-on-debian/">HowTo Create a Sudo User on Debian</a><a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Debian11</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cisco Anyconnect 和网络连接冲突</title>
    <link href="/2022/07/05/Cisco-Anyconnect/"/>
    <url>/2022/07/05/Cisco-Anyconnect/</url>
    
    <content type="html"><![CDATA[<h3 id="anyconnect-连接问题">Anyconnect 连接问题</h3><h3 id="问题发生时间">问题发生时间</h3><p>2022/07/04</p><h3 id="问题描述">问题描述</h3><p>在 Cisco Anyconnect中输入了一个地址（后来发现地址是错误的）并连接成功后，电脑就显示“无Internet，安全”。<br />另外发现此时 Anyconnect 无法更改地址，并且右键的 quit 选项消失。<br />通过重启关闭 Anyconnect 后，发现即使 Anyconnect没有运行，也无法连接网络。<br />再次打开 Anyconnect，上述情况依旧没有变化。</p><h3 id="解决方案">解决方案</h3><p><strong>重装 Anyconnect</strong><br />需要注意在设置中卸载不能解决问题，这样只是把 C:/Program Files(x86)中的程序卸载了，数据、配置等信息似乎并没有被一起删除。<br />所以需要<strong>到 C:/ProgramData/ 中删除 Cisco/ 后再重装</strong>。</p><h3 id="具体解决思路">具体解决思路</h3><ol type="1"><li>已知手机连接该网络能正常上网，所以不是网络的问题</li><li>然后尝试在电脑另一个系统中上网，可以上网则说明不是硬件的问题于是从软件的角度思考<br /></li><li>在网上搜索解决方案，大部分都是“连上 vpn 后，显示‘无Internet，安全’”，和本文的问题相似，但并不相同。试着根据那些方案修改网络设置、修改网络适配器，也确实没有应有的效果</li><li>尝试重装，从设置里卸载再重装也没有解决问题</li><li>找到一篇修改 Anyconnect 配置的博客，也不起作用</li><li>此时发现即使 Anyconnect被卸载了，其配置没有被删除，所以可能重装后的软件读取了原来有问题的配置</li><li>由于不知道原来的配置错在哪，所以索性直接删除，然后再安装</li><li>问题解决</li></ol><h3 id="后记">后记</h3><p>莫名其妙的问题还是得靠莫名其妙的方法，仅仅是做个记录。<br />大概有半年多没有用 Cisco Anyconnect了，出点问题也很正常。以后重装软件的时候还是得多留意一下是否卸载干净了。<br />这半年里为了学校里的 ROS 课程升级了win11，推测是因为系统升级导致原来的程序不可用了</p>]]></content>
    
    
    <categories>
      
      <category>Problems(Solved)</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cisco Anyconnect</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/06/19/hello-world/"/>
    <url>/2022/06/19/hello-world/</url>
    
    <content type="html"><![CDATA[<h3 id="测试">测试</h3><h3 id="一代码块">一、代码块</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String args[])</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二表格">二、表格</h3><table><thead><tr class="header"><th style="text-align: center;">0</th><th style="text-align: center;">1</th><th style="text-align: center;">2</th><th style="text-align: center;">3</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">xx</td><td style="text-align: center;">xx</td><td style="text-align: center;">xx</td><td style="text-align: center;">xx</td></tr></tbody></table><h3 id="三latex">三、Latex</h3><p><span class="math display">\[E=mc^2\]</span></p><p><span class="math display">\[P(A\rightarrow x) = \frac{weight_x}{\sum_{i=1}^{n}weight_i}\]</span></p><h3 id="四mermaid">四、Mermaid</h3><pre><code class=" mermaid">classDiagramClass01 &lt;|-- AveryLongClass : CoolClass03 *-- Class04Class05 o-- Class06Class07 .. Class08Class09 --&gt; C2 : Where am i?Class09 --* C3Class09 --|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 &lt;--&gt; C2: Cool label</code></pre><h3 id="四图片">四、图片</h3><figure><img src="/img/index/220621_helloWorld_1280x720.png"alt="Hello World" /><figcaption aria-hidden="true">Hello World</figcaption></figure><h3id="五脚注1">五、脚注<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="参考资料1">[1]</span></a></sup></h3><h2 id="参考">参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>参考资料1<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>参考资料2<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
